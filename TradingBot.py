# -*- coding: utf-8 -*-
"""TradingBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VNgh9SzLJWpnlOX4_JtxqimZ1qQFkKl1
"""

!pip install --ignore-installed lumibot==3.0.6

from lumibot.brokers import Alpaca
from lumibot.backtesting import YahooDataBacktesting
from lumibot.strategies.strategy import Strategy
from lumibot.traders import Trader

!pip install alpaca-trade-api==3.1.1 timedelta==2020.12.3

import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, pipeline
from datetime import datetime
from alpaca_trade_api import REST
from timedelta import Timedelta

from google.colab import userdata

API_KEY = userdata.get('API_KEY')
API_SECRET = userdata.get('API_SECRET')
BASE_URL = "https://paper-api.alpaca.markets/v2"
ALPACA_CREDS = {
    "API_KEY": API_KEY,
    "API_SECRET": API_SECRET,
    "PAPER": True
}

device = "cuda:0" if torch.cuda.is_available() else "cpu"

print("Loading model and tokenizer...")
model_path = "Syrinx/llama-2-finance-sentiment"
tokenizer = AutoTokenizer.from_pretrained(model_path)
model = AutoModelForCausalLM.from_pretrained(model_path, torch_dtype=torch.float16, device_map="auto")

def predict_sentiment(news):
    def predict_single_text(text):
        prompt = f"""
        Analyze the sentiment of the news headline enclosed in square brackets,
        determine if it is positive, neutral, or negative, and return the answer as
        the corresponding sentiment label "positive" or "neutral" or "negative".
        [{text}] = """
        pipe = pipeline(task="text-generation",
                        model=model,
                        tokenizer=tokenizer,
                        max_new_tokens=1,
                        do_sample=False)

        result = pipe(prompt)
        answer = result[0]['generated_text'].split("=")[-1].strip()

        if "positive" in answer:
            return "positive"
        elif "negative" in answer:
            return "negative"
        elif "neutral" in answer:
            return "neutral"
        else:
            return "none"

    sentiments = [predict_single_text(headline) for headline in news]
    if not sentiments:
        return "neutral"

    sentiment_counts = {
        "positive": sentiments.count("positive"),
        "negative": sentiments.count("negative"),
        "neutral": sentiments.count("neutral")
    }

    return max(sentiment_counts, key=sentiment_counts.get)

class MLTrader(Strategy):
    def initialize(self, symbol: str = "SPY", cash_at_risk: float = .5):
        self.symbol = symbol
        self.sleeptime = "24H"
        self.last_trade = None
        self.cash_at_risk = cash_at_risk
        self.api = REST(base_url=BASE_URL, key_id=API_KEY, secret_key=API_SECRET)

    def position_sizing(self):
        cash = self.get_cash()
        last_price = self.get_last_price(self.symbol)
        quantity = round(cash * self.cash_at_risk / last_price, 0)
        return cash, last_price, quantity

    def get_dates(self):
        today = self.get_datetime()
        three_days_prior = today - Timedelta(days=3)
        return today.strftime('%Y-%m-%d'), three_days_prior.strftime('%Y-%m-%d')

    def get_sentiment(self):
        today, three_days_prior = self.get_dates()
        news = self.api.get_news(symbol=self.symbol,
                                 start=three_days_prior,
                                 end=today)
        news = [ev.__dict__["_raw"]["headline"] for ev in news]
        sentiment = predict_sentiment(news)
        return sentiment
    def on_trading_iteration(self):
        cash, last_price, quantity = self.position_sizing()
        sentiment = self.get_sentiment()
        if cash > last_price:
            if sentiment == "positive":
                if self.last_trade == "sell":
                    self.sell_all()
                order = self.create_order(
                    self.symbol,
                    quantity,
                    "buy",
                    type="bracket",
                    take_profit_price=last_price * 1.20,
                    stop_loss_price=last_price * .95
                )
                self.submit_order(order)
                self.last_trade = "buy"
            elif sentiment == "negative":
                if self.last_trade == "buy":
                    self.sell_all()
                order = self.create_order(
                    self.symbol,
                    quantity,
                    "sell",
                    type="bracket",
                    take_profit_price=last_price * .8,
                    stop_loss_price=last_price * 1.05
                )
                self.submit_order(order)
                self.last_trade = "sell"

start_date = datetime(2023, 4, 1)
end_date = datetime(2024, 4, 1)
broker = Alpaca(ALPACA_CREDS)
strategy = MLTrader(name='mlstrat', broker=broker,
                    parameters={"symbol": "SPY",
                                "cash_at_risk": .5})

strategy.backtest(
    YahooDataBacktesting,
    start_date,
    end_date,
    parameters={"symbol": "SPY", "cash_at_risk": .5}
)

import os
import IPython

# Get a list of all HTML files in the logs folder
html_files = [f for f in os.listdir('/content/logs/') if f.endswith('.html')]

# Sort the list alphabetically in descending order
html_files.sort(reverse=True)

# Get the path to the last and 3rd last files
last_file_path = os.path.join('/content/logs/', html_files[0])
second_last_file_path = os.path.join('/content/logs/', html_files[1])

print("Last HTML file:", last_file_path)
print("3rd last HTML file:", second_last_file_path)

IPython.display.HTML(open(last_file_path, 'r').read())

IPython.display.HTML(open(second_last_file_path, 'r').read())



